.Message {
    text-align: left;
    color: black;
    background-color: white;
    border-style: solid;
    border-width: thin;
    padding-left: 10px;
}

.Error {
    text-align: left;
    color: red;
    background-color: white;
    border-style: solid;
    border-width: thin;
    padding-left: 10px;
}

.Warning
{
    text-align: left;
    color: red;
    text-decoration-style: wavy;
    background-color: white;
    border-style: solid;
    border-width: thin;
    padding-left: 10px;
}

PS_OUTPUT PS_Main(PS_INPUT input)
{
    PS_OUTPUT Out = (PS_OUTPUT) 0;
    Out.Color = float4(1, 0, 0, 1);
   
    const float2 vec[4] =
    {
        float2(1, 0), float2(-1, 0), float2(0, 1), float2(0, -1)
    };
   
    float4 p = GetPosition(input.TexCoord);
    float3 n = Decode(GetNormal(input.TexCoord).xy);
    float2 rand = GetRandom(input.TexCoord);
   
    float ao = 0.0f;
    float rad = Sampler_Radius / p.z;
   
    int iterations = 4;
    for (int j = 0; j < iterations; ++j)
    {
        float2 coord1 = reflect(vec[j], rand) * rad;
      ///El 0.707 es especifico porque quiero moverme eso en textura, es poco mÃ¡s de la media del pixel.
        float2 coord2 = float2(coord1.x - coord1.y * 0.707,
                             coord1.x + coord1.y * 0.707);
                             
        ao += DoAmbientOcclusion(input.TexCoord, coord1 * 0.25, p.xyz, n);
        ao += DoAmbientOcclusion(input.TexCoord, coord2 * 0.5, p.xyz, n);
        ao += DoAmbientOcclusion(input.TexCoord, coord1 * 0.75, p.xyz, n);
        ao += DoAmbientOcclusion(input.TexCoord, coord2, p.xyz, n);
    }
   
    ao /= (iterations * 4);
	Out.Color = ao.xxxx;
   
    return Out;
}
